---
layout: 	post
title: 		"第六章 类再生"
subtitle:	" \"读书笔记\""
date:		2019-04-17 23:30:00
author:		"duwanjiang"
header-img:	"img/about-bg-walle.jpg"
catalog: true
categories: Java
tags:
    - 《Thinking In Java》

---

> “从现在开始实现你的梦想，就不晚 ”


# 6.1 合成的语法

就是将ClassA作为ClassB的成员变量，即为合成

# 6.2 继承的语法

## 6.2.1 初始化基础类

子类初始化时，会默认调用所有父类的默认构造函数，即：初始化子类时，其所有父类都会被初始化，且顺序为从上到下（父-->子）

# 6.3 合成与继承的结合

## 6.3.1 确保正确的清除

Java的垃圾收集器会自动收集无用的对象，但是收集顺序我们无法控制

## 6.3.2 名字的隐藏

子类可以重写父类的方法，返回值和方法名相同，但是参数类型不同

# 6.4 到底选择合成还是继承

如果想利用新类内部一个现有类的特性，而不想使用它的接口，通常应选择合成。也就是说，我们可嵌入一个对象，使自己能用它实现新类的特性。但新类的用户会看到我们已定义的接口，而不是来自嵌入对象的接口。考虑到这种效果，我们需在新类里嵌入现有类的private 对象。有些时候，我们想让类用户直接访问新类的合成。也就是说，需要将成员对象的属性变为public。成员对象会将自身隐藏起来，所以这是一种安全的做法。而且在用户知道我们准备合成一系列组件时，接口就更容易理解。

# 6.5 protected

# 6.6 累积开发

继承的一个好处是它支持“累积开发”，允许我们引入新的代码，同时不会为现有代码造成错误。这样可将新错误隔离到新代码里。

# 6.7 上溯造型

新类属于现有类的一种类型

## 6.7.1 何谓“上溯造型”？
之所以叫作这个名字，除了有一定的历史原因外，也是由于在传统意义上，类继承图的画法是根位于最顶部，再逐渐向下扩展。由于造型的方向是从衍生类到基础类，箭头朝上，所以通常把它叫作“上溯造型”，即Upcasting。

# 6.8 final关键字

## 6.8.1 final数据

1. 编译期常数，它永远不会改变
2. 在运行期初始化的一个值，我们不希望它发生变化对于编译期的常数，编译器（程序）可将常数值“封装”到需要的计算过程里。也就是说，计算可在编译期间提前执行，从而节省运行时的一些开销。在 Java 中，这些形式的常数必须属于基本数据类型（Primitives），而且要用 final 关键字进行表达。在对这样的一个常数进行定义的时候，必须给出一个值。

## 6.8.2 final方法

之所以要使用final 方法，可能是出于对两方面理由的考虑。第一个是为方法“上锁”，防止任何继承类改变它的本来含义。设计程序时，若希望一个方法的行为在继承期间保持不变，而且不可被覆盖或改写，就可以采取这种做法。

## 6.8.3 final类

如果说整个类都是 final（在它的定义前冠以 final 关键字），就表明自己不希望从这个类继承，或者不允许其他任何人采取这种操作。

## 6.8.4 final的注意事项

设计一个类时，往往需要考虑是否将一个方法设为 final。可能会觉得使用自己的类时执行效率非常重要，没有人想覆盖自己的方法。这种想法在某些时候是正确的，但要慎重作出自己的假定。

# 6.9 初始化和类装载

## 6.9.1 继承初始化

类装载的时候，所有static 对象和 static 代码块都会按照本来的顺序初始化（亦即它们在类定义代码里写入的顺序）。当然，static 数据只会初始化一次。

# 思维导图

![]({{"\img\posts_img\technology\ThinkingInJava\第六章 类再生.png"| prepend:site.url}})

