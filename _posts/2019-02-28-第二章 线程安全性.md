---
layout: 	post
title: 		"第二章、线程安全性"
subtitle:	" \"读书笔记\""
date:		2019-02-28 22:34:00
author:		"duwanjiang"
header-img:	"img/home-bg-o.jpg"
catalog: true
tags:
    - 《java并发编程实战》
---

> “从现在开始实现你的梦想，就不晚 ”



# 1.1、什么是线程安全性？
    当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程讲如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类始终都能表现出正确的行为，那么就可称这个类是线程安全的。

* 在线程安全性的定义中，最核心的概念就是正确性。正确性的含义是，某个类的行为与其规范完全一致。

* 如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：
  （1）不在线程之间共享该状态变量
  （2）将状态变量修改为不可变的变量
  （3）在访问状态变量时使用同步。
* 当设计线程安全的类时，良好的面相对象技术、不可修改性，以及明晰的不可变性规范都能起到一定的帮助作用。
* 无状态对象（它既不包含任何域，也不包含任何对其他类中域的引用）一定是线程安全的
# 1.2、原子性
   原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说就是原子的。
## 1.2.1、竞态条件（Race Condition）
    在并发编程中，由于多线程不恰当的执行时序而出现不正确的结果的情况就是竞态条件。
## 1.2.2、复合操作
    为了确保线程安全性，“先检查后执行”（例如延迟初始化）和“读取-修改-写入”（例如递增运算）等操作必须是原子的。我们将“先检查后执行”以及“读取-修改-写入”等操作统称为复合操作：包含了一组必须以原子方式执行的操作以确保线程安全性。
* 在实际情况中，应尽可能地使用现有的线程安全对象（例如AcomicLong）来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。
# 1.3、加锁机制
* 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。
## 1.3.1、内置锁
    每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视锁（Monitor Lock）。关键字为synchronized。
## 1.3.2、重入
    当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁时可重入的，因此如果某个线程试图获取一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”。
# 1.4、用锁来保护状态
    对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。
* 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。
* 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。
# 1.5、活跃性与性能
* 通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破坏安全性）
* 当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。